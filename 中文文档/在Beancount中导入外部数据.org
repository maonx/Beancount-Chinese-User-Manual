#+TITLE: 在Beancount中导入外部数据
#+DATE: [2020-04-27 周一]
#+AUTHOR: Martin Blais

* 简介
这是 Beancount 中的库和工具的用户手册，可以帮助您将外部交易数据自动导入到您的 Beancount 输入文件中，并管理您从金融机构网站下载的文件。

* 导入过程
人们经常想知道我们是怎么做的，所以让我在这里直截了当地详细描述一下我们要做的事情。

目前的任务的本质是将一个人的整个账户集中发生的交易转录到一个单一的文本文件：Beancount 输入文件。将整个交易集录入到一个系统中，是我们需要做的事情，以便生成关于一个人的财富和支出的综合报告。有人把这叫做 "对账"。

我们可以把纸质报表上的所有交易都用手抄录下来，只需把它们打进去就可以了。但是现在大多数金融机构都有一个网站，你可以通过下载到一些数据格式的历史交易报表来解析输出 Beancount 语法。

从这些单据中导入交易，需要：
- 手动审查交易的正确性甚至是欺诈行为。
- 将新的交易与之前从其他账户导入的交易进行合并。例如，从银行账户支付信用卡的款项，通常会从银行和信用卡账户导入。您必须手动将相应的交易合并到一起。
- 为支出交易分配正确的类别 
- 通过将产生的指令移动到文件中的正确位置来组织你的文件。
- 核查余额，要么直观地核实余额，要么插入一个余额指令，说明新的交易后的最终账户余额应该是多少。

如果我的导入器正常工作，没有 bug 的话，这个过程需要 30-60 分钟来更新我的大部分活跃账户。不太活跃的账户每季度更新一次，或者在我觉得合适的时候更新。我倾向于在周六早上做这个，也许每个月两次，有时每周一次。如果你保持一个有条理的输入文件，有大量的断言，错误很容易被发现，这是一个愉快而简单的过程，而且在你完成后，生成一个更新的资产负债表是很有成就感的（我通常会重新导出到 Google Finance 的投资组合中）。

* 自动化网络下载
文件的下载并不是我自动完成的，Beancount 也没有提供任何工具来连接到网络并获取文件。外面的协议种类太多，根本无法对这个问题做出有意义的贡献。考虑到当今安全网站的性质和用于实现这些网站的 JavaScript 城堡，这将是一场噩梦。网络抓取很可能是一个值得、可行的解决方案。

我用我的用户名和密码手动登录到各个网站，然后点击右边的按钮，生成我需要的下载文件。这些文件会被导入器自动识别，并通过本文中描述的工具自动提取事务并将文件归档到有条理的目录层次结构中。
虽然我没有脚本化提取，但我认为在某些网站上是可以这样做的。这些工作就留给你在你认为值得的地方去实现了。

* 典型下载
下面是对所涉及的典型文件类型的描述；这描述了我的用例和我所做的事情。这应该能让你对所涉及的内容有一个定性的认识。
- 信用卡和银行提供了质量相当好的 OFX 或 CSV 文件格式的历史对账单下载，但我需要对这些交易的另一面进行手动分类，并将一些交易合并到一起。
- 投资账户为我提供了高质量的可处理的报表，提取购买交易是完全自动化的，但我需要手动编辑销售交易，以关联正确的成本基础。有些机构的专业产品（如 P2P 网贷）只提供 PDF 文件，而这些文件都是人工翻译的。
- 工资单存根和归属事件通常只提供 PDF 格式，我懒得尝试自动提取数据；我手动抄录这些数据，保持输入非常有规律，并按照报表上的顺序排列。这样做会更容易些。
- 现金交易。我必须手动输入这些数据。我只把非食品类的支出直接记为单笔交易，对于食品类的支出，可能每半年我都会算一次钱包余额，然后插入一个汇总交易，每个月从食品现金账户中扣掉一部分，以使其保持平衡。如果你这样做，你最终需要手动输入的交易量会出奇地少，也许每周只需要输入几笔（这取决于生活方式的选择，这对我来说很管用）。当我出差的时候，我只是在手机上的 Google Keep 里记下这些，最后在积累后再抄录下来。

* 从 PDF 文件中提取数据
我已经在转换 PDF 文件中的数据方面取得了一些进展，这是一个普遍的需求，但还不完整；事实证明，在一般情况下，从 PDF 中完全自动提取表格并不容易。我有一些接近可以工作的代码，当时机成熟的时候会发布。另一方面，我找到的最好的 FOSS 解决方案是一个叫 TabulaPDF 的工具，但你仍然需要手动识别数据表在页面上的位置；你也许可以通过它的姐妹项目 tabula-java 自动提取一些。

尽管如此，我的导入器通常能成功地将 PDF 转换为难看的文本，以识别出它们是为哪个机构服务的，并提取出文件的发布日期。

最后，有许多不同的工具能从 PDF 文档中提取文本，如 PDFMiner、LibreOffice、xpdf 库、poppler 库等等..........但没有一个能在所有输入文档上一致地工作；你很可能最终会安装许多工具，并依赖不同的工具来处理不同的输入文件。出于这个原因，我并不要求在 Beancount 内部依赖 PDF 转换工具。你应该测试哪些工具在你的特定文档上有效，然后从你的导入器实现中调用这些工具。

* 工具
提供了三个 Beancount 工具来协调导入的三个阶段：
1. bean-identify: 给出一个杂乱的下载文件列表（例如在 ~/Downloads 中），自动识别你配置的导入器里的哪些文件能够处理并打印出来。这是用于调试和确定你的配置是否为每个下载的文件正确地关联了一个合适的导入器。
2. bean-extract: 如果可能的话，从每个文件中提取交易和日期。这将产生一些 Beancount 输入文本并转移到你的输入文件中。
3. bean-file: 将下载的文件归档到一个目录层次结构中，镜像账目表，以便保存，例如在个人的 git repo 中。清理文件名，移动文件并在每个文件上预留适当的声明日期，这样 Beancount 就可以产生相应的 Document 指令。

* 调用
所有工具都接受相同的输入参数:
#+BEGIN_SRC beancount
bean-<tool> <config> <downloads-dir>
#+END_SRC

例如：
#+BEGIN_SRC beancount
bean-extract blais.config ~/Downloads
#+END_SRC

归档工具接受一个额外的选项，让用户决定将文件移动到哪里，例如：
#+BEGIN_SRC beancount
bean-file -o ~/accounting/documents blais.config ~/Downloads
#+END_SRC

它的默认行为是将文件移动到与配置文件相同的目录。

* 配置
前面介绍的工具协调了这些过程，但它们并没有做很多具体的工作，比如摸索各个下载对象本身。它们在导入器对象上调用方法。你必须提供一个这样的导入器列表；这个列表就是导入过程的配置（没有它，那些工具就没有任何作用）。

对于每个找到的文件，每个导入器都会被调用，以确定它是否可以或不能处理该文件。如果它认为可以，可以调用方法来生成一个交易列表，提取一个日期，或者为下载的文件生成一个清理过的文件名。

配置应该是一个 Python3 模块，你在其中实例化导入器并将列表分配给模块级的 "CONFIG" 变量，就像这样:
#+BEGIN_SRC python
#!/usr/bin/env python3
from myimporters.bank import acmebank
from myimporters.bank import chase
…

CONFIG = [
  acmebank.Importer(),
  chase.Importer(),
  …
]
#+END_SRC


当然，既然你在制作一个 Python 脚本，你可以在里面插入任何你喜欢的其他代码。重要的是，这个 "CONFIG" 变量指的是一个符合导入器协议的对象列表 (在下一节中描述)。它们的顺序并不重要。

特别是，在编写导入器的时候，最好尽可能的通用化，并且用你在输入文件中使用的特定帐户名称作为参数。这有助于保持你的代码独立于特定的账户，并迫使你定义逻辑账户，我发现这样做有助于代码更清晰。

或者不是...........到了最后，这些导入器代码住在你自己的一些私人地方，而不是和 Beancount 一起。如果你愿意的话，你可以把它们保持混乱和不可共享，只要你愿意。

** 从输入文件进行配置
一个有趣的想法，我还没有测试过，那就是用自己的 Beancount 输入文件来推断导入器的配置。如果你想尝试一下这个方法，并修改一些内容，你可以通过使用 API 的 beancount.loader.load_file()函数，从导入配置的 Python config 中加载你的输入文件。

* 编写导入器
每个导入器必须遵守特定的协议，并至少实现其中的一些方法。这个协议的全部细节最好在源代码中找到：importer.py。上面的工具将负责查找下载并在你的 importer 对象上调用适当的方法。

以下是你需要或可能想要实现的方法的简要总结：
- name(): 这个方法为每个导入器实例提供了一个唯一的 id。可以方便的用一个唯一的名字来引用你的导入器，例如，它被标识过程打印出来。
- Identify(): 这个方法只是返回 true，如果这个导入器可以处理给定的文件，则返回 true。你必须实现这个方法，所有的工具都会调用它来计算出（文件、导入器）对的列表。
- extract(): 这个方法被调用来尝试从文件内容中提取一些 Beancount 指令。它必须通过实例化 beancount.core.data 中定义的对象来创建这些指令并返回它们。
- file_account(): 该方法返回与此导入器关联的根帐户。这就是下载的文件将被存档脚本移动的地方。
- file_date(): 如果可以从语句的内容中提取出日期，在这里返回日期。这对于有日期的 PDF 语句很有用...........通常可以使用正则表达式从转换为文本的 PDF 中提取出日期。这可以让文档脚本预置一个相关的日期，而不是使用文件下载时的日期（默认值）。
- file_name(): 这是最方便的，不用费心重命名下载的文件。通常情况下，从你的银行生成的文件要么都有一个唯一的名字，当你下载多个文件时，这些文件最终会被浏览器重命名，而这些文件的名字也会发生碰撞。这个功能是用来给导入器提供一个"好听"的名字来给下载的文件命名的。

  所以基本上，你在你的 PYTHONPATH 上的某个地方创建一些模块----任何你喜欢的地方，私人的地方----然后你实现一个类，类似于这样的类：
  #+BEGIN_SRC python
from beancount.ingest import importer

class Importer(importer.ImporterProtocol):

    def identify(self, file):
        …

    # Override other methods…

  #+END_SRC

  通常情况下，我在每个导入器的专用目录中创建导入器模块文件，这样我就可以将输入的示例文件全部放在该目录中进行回归测试。
